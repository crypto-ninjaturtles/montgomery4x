/*
 * This file is in public domain.
 *
 * Authors: Huseyin Hisil, Berkan Egrice, Mert Yassi
 * Title:   Fast 4 way vectorized ladder for the complete set of Montgomery curves
 * Version: 2019-02-13
 *
 */

#include "datatype.h"

void set_base(vec *z, const gfe *a, const gfe *b) {
	int i;
	((u64 *)&z[0])[0] = 1; 			// Z1
	((u64 *)&z[0])[1] = 0;          // Z1
	((u64 *)&z[0])[2] = a->v[0];	// X1
	((u64 *)&z[0])[3] = a->v[5];    // X1
	((u64 *)&z[0])[4] = 0;			// unused
	((u64 *)&z[0])[5] = 0;          // unused
	((u64 *)&z[0])[6] = b->v[0];	// A
	((u64 *)&z[0])[7] = b->v[5];    // A
	for (i = 1; i < 5; i++) {
		((u64 *)&z[i])[0] = 0;
		((u64 *)&z[i])[1] = 0;
		((u64 *)&z[i])[2] = a->v[i];
		((u64 *)&z[i])[3] = a->v[i+5];
		((u64 *)&z[i])[4] = 0;
		((u64 *)&z[i])[5] = 0;
		((u64 *)&z[i])[6] = b->v[i];
		((u64 *)&z[i])[7] = b->v[i+5];
	}
}

void set_vector(vec *z, const gfe *a) {
	int i;
	((u64 *)&z[0])[0] = a->v[0];	// X1
	((u64 *)&z[0])[1] = a->v[5];	// X1
	((u64 *)&z[0])[2] = 1;			// Z1
	((u64 *)&z[0])[3] = 0;			// Z1
	((u64 *)&z[0])[4] = 1;			// X2 = 1
	((u64 *)&z[0])[5] = 0;          // X2
	((u64 *)&z[0])[6] = 0;			// Z2 = 0
	((u64 *)&z[0])[7] = 0;          // Z2
	for (i = 1; i < 5; i++) {
		((u64 *)&z[i])[0] = a->v[i];
		((u64 *)&z[i])[1] = a->v[i+5];
		((u64 *)&z[i])[2] = 0;
		((u64 *)&z[i])[3] = 0;
		((u64 *)&z[i])[4] = 0;
		((u64 *)&z[i])[5] = 0;
		((u64 *)&z[i])[6] = 0;
		((u64 *)&z[i])[7] = 0;
	}
}

void reduce_unique(gfe *a){
	u64 c = (a->v[1] == p25519_1(1)) &&
			(a->v[2] == p25519_2(1)) &&
			(a->v[3] == p25519_3(1)) &&
			(a->v[4] == p25519_4(1)) &&
			(a->v[5] == p25519_5(1)) &&
			(a->v[6] == p25519_6(1)) &&
			(a->v[7] == p25519_7(1)) &&
			(a->v[8] == p25519_8(1)) &&
			(a->v[9] == p25519_9(1)) &&
			(a->v[0] >= p25519_0(1));
	u64 d = 1-c;
	a->v[0] = d * a->v[0] + (c * (a->v[0] - p25519_0(1)));
	a->v[1] = d * a->v[1];
	a->v[2] = d * a->v[2];
	a->v[3] = d * a->v[3];
	a->v[4] = d * a->v[4];
	a->v[5] = d * a->v[5];
	a->v[6] = d * a->v[6];
	a->v[7] = d * a->v[7];
	a->v[8] = d * a->v[8];
	a->v[9] = d * a->v[9];
}

void get_channel(gfe *z, const vec *a, const int ch) {
	int i;
	for(i = 0; i < NLIMB; i++){
		z->v[i] = ((u64 *)&a[i])[2*ch];
		z->v[i+5] = ((u64 *)&a[i])[2*ch+1];
	}
}

void gfe64_pack(gfe64 *z, const gfe *a){
	z->v[0]  = (a->v[0] & 0x3ffffffUL);       /*26*/
	z->v[0] |= (a->v[1] & 0x1ffffffUL) << 26; /*26+25*/
	z->v[0] |= (a->v[2] & 0x1fffUL) << 51;    /*26+25+13*/
	z->v[1]  = (a->v[2] >> 13);               /*13*/
	z->v[1] |= (a->v[3] & 0x1ffffffUL) << 13; /*13+25*/
	z->v[1] |= (a->v[4] & 0x3ffffffUL) << 38; /*13+25+26*/
	z->v[2]  = (a->v[5] & 0x1ffffffUL);       /*25*/
	z->v[2] |= (a->v[6] & 0x3ffffffUL) << 25; /*26+25*/
	z->v[2] |= (a->v[7] & 0x1fffUL) << 51;    /*26+25+13*/
	z->v[3]  = (a->v[7] >> 13);               /*12*/
	z->v[3] |= (a->v[8] & 0x3ffffffUL) << 12; /*12+26*/
	z->v[3] |= (a->v[9] & 0x1ffffffUL) << 38; /*12+26+25*/
}

void char_to_gfe(gfe *z, const unsigned char a[32]) {
	//26
	z->v[0] = a[0]; /*8*/
	z->v[0] |= ((u64)a[1] << 8); /*16*/
	z->v[0] |= ((u64)a[2] << 16); /*24*/
	z->v[0] |= ((u64)(a[3] & 0x03) << 24); /*26*/
	//25
	z->v[1] = ((u64)(a[3] & 0xfc) >> 2); /*6*/
	z->v[1] |= ((u64)a[4] << 6); /*14*/
	z->v[1] |= ((u64)a[5] << 14); /*22*/
	z->v[1] |= ((u64)(a[6] & 0x07) << 22); /*25*/
	//26
	z->v[2] = ((u64)(a[6] & 0xf8) >> 3); /*5*/
	z->v[2] |= ((u64)a[7] << 5); /*13*/
	z->v[2] |= ((u64)a[8] << 13); /*21*/
	z->v[2] |= ((u64)(a[9] & 0x1f) << 21); /*26*/
	//25
	z->v[3] = ((u64)(a[9] & 0xe0) >> 5); /*3*/
	z->v[3] |= ((u64)a[10] << 3); /*11*/
	z->v[3] |= ((u64)a[11] << 11); /*19*/
	z->v[3] |= ((u64)(a[12] & 0x3f) << 19); /*25*/
	//26
	z->v[4] = ((u64)(a[12] & 0xc0) >> 6); /*2*/
	z->v[4] |= ((u64)a[13] << 2); /*10*/
	z->v[4] |= ((u64)a[14] << 10); /*18*/
	z->v[4] |= ((u64)a[15] << 18); /*26*/
	//25
	z->v[5] = a[16]; /*8*/
	z->v[5] |= ((u64)a[17] << 8); /*16*/
	z->v[5] |= ((u64)a[18] << 16); /*24*/
	z->v[5] |= ((u64)(a[19] & 0x01) << 24); /*25*/
	//26
	z->v[6] = ((u64)(a[19] & 0xfe) >> 1); /*7*/
	z->v[6] |= ((u64)a[20] << 7); /*15*/
	z->v[6] |= ((u64)a[21] << 15); /*23*/
	z->v[6] |= ((u64)(a[22] & 0x07) << 23); /*26*/
	//25
	z->v[7] = ((u64)(a[22] & 0xf8) >> 3); /*5*/
	z->v[7] |= ((u64)a[23] << 5); /*13*/
	z->v[7] |= ((u64)a[24] << 13); /*21*/
	z->v[7] |= ((u64)(a[25] & 0x0f) << 21); /*25*/
	//26
	z->v[8] = ((u64)(a[25] & 0xf0) >> 4); /*4*/
	z->v[8] |= ((u64)a[26] << 4); /*12*/
	z->v[8] |= ((u64)a[27] << 12); /*20*/
	z->v[8] |= ((u64)(a[28] & 0x3f) << 20); /*26*/
	//25
	z->v[9] = ((u64)(a[28] & 0xc0) >> 6); /*2*/
	z->v[9] |= ((u64)a[29] << 2); /*10*/
	z->v[9] |= ((u64)a[30] << 10); /*18*/
	z->v[9] |= ((u64)a[31] << 18); /*26*/
}
