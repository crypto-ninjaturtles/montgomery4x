/*
 * This file is in public domain.
 *
 * Authors: Huseyin Hisil, Berkan Egrice, Mert Yassi
 * Title:   Fast 4 way vectorized ladder for the complete set of Montgomery curves
 * Version: 2019-02-13
 *
 */

#include "datatype.h"

void set_base(vec *z, const gfe *a, const gfe *b) {
	int i;
	((u64 *)&z[0])[0] = 1;        // Z1
	((u64 *)&z[0])[1] = a->v[0];  // X1
	((u64 *)&z[0])[2] = 0;        // unused
	((u64 *)&z[0])[3] = b->v[0];  // A
	for (i = 1; i < 9; i++) {
		((u64 *)&z[i])[0] = 0;
		((u64 *)&z[i])[1] = a->v[i];
		((u64 *)&z[i])[2] = 0;
		((u64 *)&z[i])[3] = b->v[i];
	}
}

void set_vector(vec *z, const gfe *a) {
	int i;
	((u64 *)&z[0])[0] = a->v[0];  // X1
	((u64 *)&z[0])[1] = 1;        // Z1
	((u64 *)&z[0])[2] = 1;        // X2 = 1
	((u64 *)&z[0])[3] = 0;        // Z2 = 0
	for (i = 1; i < 9; i++) {
		((u64 *)&z[i])[0] = a->v[i];
		((u64 *)&z[i])[1] = 0;
		((u64 *)&z[i])[2] = 0;
		((u64 *)&z[i])[3] = 0;
	}
}

void reduce_unique(gfe *z){
	u64 c = (z->v[1] == p25519_1(1)) &&
			(z->v[2] == p25519_2(1)) &&
			(z->v[3] == p25519_3(1)) &&
			(z->v[4] == p25519_4(1)) &&
			(z->v[5] == p25519_5(1)) &&
			(z->v[6] == p25519_6(1)) &&
			(z->v[7] == p25519_7(1)) &&
			(z->v[8] == p25519_8(1)) &&
			(z->v[0] >= p25519_0(1));
	u64 d = 1-c;
	z->v[0] = d * z->v[0] + (c * (z->v[0] - p25519_0(1)));
	z->v[1] = d * z->v[1];
	z->v[2] = d * z->v[2];
	z->v[3] = d * z->v[3];
	z->v[4] = d * z->v[4];
	z->v[5] = d * z->v[5];
	z->v[6] = d * z->v[6];
	z->v[7] = d * z->v[7];
	z->v[8] = d * z->v[8];
}

void get_channel(gfe *z, const vec *a, const int ch) {
	int i;
	for(i = 0; i < NLIMB; i++){
		z->v[i] = ((u64 *)&a[i])[ch];
	}
}

void gfe64_pack(gfe64 *z, const gfe *a){
	z->v[0]  = (a->v[0] & 0x1fffffffUL);       /*29*/
	z->v[0] |= (a->v[1] & 0xfffffffUL) << 29;  /*29+28*/
	z->v[0] |= (a->v[2] & 0x7fUL) << 57;       /*29+28+7*/
	z->v[1]  = (a->v[2] >> 7);                 /*21*/
	z->v[1] |= (a->v[3] & 0x1fffffffUL) << 21; /*21+29*/
	z->v[1] |= (a->v[4] & 0x3fffUL) << 50;     /*21+29+14*/
	z->v[2]  = (a->v[4] >> 14);                /*14*/
	z->v[2] |= (a->v[5] & 0xfffffffUL) << 14;  /*14+28*/
	z->v[2] |= (a->v[6] & 0x3fffffUL) << 42;   /*14+28+22*/
	z->v[3]  = (a->v[6] >> 22);                /*7*/
	z->v[3] |= (a->v[7] & 0xfffffffUL) << 7;   /*7+28*/
	z->v[3] |= (a->v[8] & 0xfffffffUL) << 35;  /*7+28+28*/
}


void char_to_gfe(gfe *z, const unsigned char a[32]) {
	//29
	z->v[0]  = a[0];
	z->v[0] |= ((u64)a[1] << 8);
	z->v[0] |= ((u64)a[2] << 16);
	z->v[0] |= ((u64)(a[3] & 0x1f) << 24);
	//28
	z->v[1]  = ((u64)(a[3] & 0xe0) >> 5);
	z->v[1] |= ((u64)a[4] << 3);
	z->v[1] |= ((u64)a[5] << 11);
	z->v[1] |= ((u64)a[6] << 19);
	z->v[1] |= ((u64)(a[7] & 0x1) << 27);
	//28
	z->v[2] =  ((u64)(a[7] & 0xfe) >> 1);
	z->v[2] |= ((u64)a[8] << 7);
	z->v[2] |= ((u64)a[9] << 15);
	z->v[2] |= ((u64)(a[10] & 0x1f) << 23);
	//29
	z->v[3] =  ((u64)(a[10] & 0xe0) >> 5);
	z->v[3] |= ((u64)a[11] << 3);
	z->v[3] |= ((u64)a[12] << 11);
	z->v[3] |= ((u64)a[13] << 19);
	z->v[3] |= ((u64)(a[14] & 0x3) << 27);
	//28
	z->v[4] =  ((u64)(a[14] & 0xfc) >> 2);
	z->v[4] |= ((u64)a[15] << 6);
	z->v[4] |= ((u64)a[16] << 14);
	z->v[4] |= ((u64)(a[17] & 0x3f) << 22);
	//28
	z->v[5] =  ((u64)(a[17] & 0xc0) >> 6);
	z->v[5] |= ((u64)a[18] << 2);
	z->v[5] |= ((u64)a[19] << 10);
	z->v[5] |= ((u64)a[20] << 18);
	z->v[5] |= ((u64)(a[21] & 0x3) << 26);
	//29
	z->v[6] =  ((u64)(a[21] & 0xfc) >> 2);
	z->v[6] |= ((u64)a[22] << 6);
	z->v[6] |= ((u64)a[23] << 14);
	z->v[6] |= ((u64)(a[24] & 0x7f) << 22);
	//28
	z->v[7] =  ((u64)(a[24] & 0x80) >> 7);
	z->v[7] |= ((u64)a[25] << 1);
	z->v[7] |= ((u64)a[26] << 9);
	z->v[7] |= ((u64)a[27] << 17);
	z->v[7] |= ((u64)(a[28] & 0x7) << 25);
	//28
	z->v[8] = ((u64)(a[28] & 0xf8) >> 3);
	z->v[8] |= ((u64)a[29] << 5);
	z->v[8] |= ((u64)a[30] << 13);
	z->v[8] |= ((u64)a[31] << 21);
}

